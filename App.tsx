
import React, { useState } from 'react';
import { ImageModal, GeneratedContent } from './components/ImageModal';
import { generateImage } from './services/geminiService';
import { getShuffledDictionary, VisualDictionaryEntry } from './services/dictionaryService';
import { ImageIcon } from './components/icons/ImageIcon';
import { DiceIcon } from './components/icons/DiceIcon';
import { WordCard } from './components/WordCard';

/**
 * Creates a single vertical image by combining a source image with dictionary text.
 * @param imageUrl The URL of the base image generated by the AI.
 * @param entry The dictionary entry containing the text to render.
 * @returns A promise that resolves with a data URL for the new combined image.
 */
const createCombinedImage = (imageUrl: string, entry: VisualDictionaryEntry): Promise<string> => {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous'; // Required for loading external images onto a canvas

        img.onload = () => {
            const canvas = document.createElement('canvas');
            const imageSize = 1024; // Base size of the generated square image
            const padding = 60;
            const textSectionHeight = 500; // Extra space for the text below the image

            canvas.width = imageSize;
            canvas.height = imageSize + textSectionHeight;
            const ctx = canvas.getContext('2d');

            if (!ctx) {
                return reject(new Error('Could not get canvas context'));
            }

            // Set a rustic background color for the entire canvas
            ctx.fillStyle = '#292524'; // Corresponds to stone-800
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw the AI-generated image at the top
            ctx.drawImage(img, 0, 0, imageSize, imageSize);
            
            let currentY = imageSize + padding * 1.5;
            const maxWidth = canvas.width - (padding * 2);

            // Helper function to wrap long lines of text
            const wrapText = (text: string, x: number, y: number, lineHeight: number): number => {
                const words = text.split(' ');
                let line = '';
                for (const word of words) {
                    const testLine = line + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && line.length > 0) {
                        ctx.fillText(line.trim(), x, y);
                        line = word + ' ';
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line.trim(), x, y);
                return y + lineHeight;
            };

            // Render "Kriol Word"
            ctx.font = 'bold 48px serif';
            ctx.fillStyle = '#facc15'; // Corresponds to amber-400
            ctx.fillText(entry.kriol, padding, currentY);
            currentY += 70;

            // Render "English Meaning" heading
            ctx.font = 'bold 28px serif';
            ctx.fillStyle = '#facc15'; // amber-400
            ctx.fillText('English Meaning', padding, currentY);
            currentY += 40;

            // Render the detailed meaning
            ctx.font = '26px sans-serif';
            ctx.fillStyle = '#d6d3d1'; // Corresponds to stone-300
            currentY = wrapText(entry.meaning, padding, currentY, 32);
            currentY += 40;
            
            // Render "Example" heading
            ctx.font = 'bold 24px serif';
            ctx.fillStyle = '#facc15'; // amber-400
            ctx.fillText('Example', padding, currentY);
            currentY += 35;
            
            // Render Kriol example sentence (with wrapping)
            ctx.font = 'italic 26px sans-serif';
            ctx.fillStyle = '#d6d3d1'; // stone-300
            currentY = wrapText(`"${entry.kriolExample}"`, padding, currentY, 32);
            
            // Render English example sentence (with wrapping)
            ctx.font = 'italic 22px sans-serif';
            ctx.fillStyle = '#a8a29e'; // stone-400
            wrapText(`(${entry.englishExample})`, padding, currentY + 5, 28);

            resolve(canvas.toDataURL('image/png'));
        };

        img.onerror = () => {
            reject(new Error('Failed to load base image for canvas rendering.'));
        };

        img.src = imageUrl;
    });
};


const App: React.FC = () => {
  // State for Image Generation Modal
  const [isImageModalOpen, setIsImageModalOpen] = useState(false);
  const [isGeneratingImage, setIsGeneratingImage] = useState(false);
  const [generatedContent, setGeneratedContent] = useState<GeneratedContent | null>(null);
  const [generationError, setGenerationError] = useState<string | null>(null);

  // State for the currently displayed word
  const [pickedWord, setPickedWord] = useState<VisualDictionaryEntry | null>(null);
  // State to manage the shuffled "deck" of words, ensuring no repeats.
  const [wordDeck, setWordDeck] = useState<VisualDictionaryEntry[]>(() => getShuffledDictionary());

  const handleGenerateImage = async () => {
    if (!pickedWord) {
      // This case is unlikely as the button is disabled, but it's a good safeguard.
      setGenerationError("Please pick a word first before trying to generate an image.");
      setIsImageModalOpen(true);
      return;
    }

    setIsImageModalOpen(true);
    setIsGeneratingImage(true);
    setGeneratedContent(null);
    setGenerationError(null);

    try {
      const entry = pickedWord;
      
      const prompt = `A photorealistic image of a single ${entry.englishForPrompt}, centered on a plain tan background, studio lighting.`;
      const baseImageUrl = await generateImage(prompt);
      
      const combinedImageUrl = await createCombinedImage(baseImageUrl, entry);

      setGeneratedContent({
        imageUrl: combinedImageUrl,
        kriol: entry.kriol,
        meaning: entry.meaning,
        kriolExample: entry.kriolExample,
        englishExample: entry.englishExample,
      });

    } catch (error) {
      console.error("Failed to generate image:", error);
      let errorMessage = "Sorry, I couldn't create an image right now. Please try again.";
      const errorString = JSON.stringify(error);

      if (error instanceof Error && error.message.includes("API_KEY")) {
        errorMessage = "It appears the API Key is missing or invalid. I cannot connect to the digital realm without it.";
      } else if (errorString.includes("PERMISSION_DENIED")) {
        errorMessage = "A 'Permission Denied' error occurred. This could mean the API Key is incorrect or doesn't have access to the required services.";
      } else if (errorString.includes("RESOURCE_EXHAUSTED") || errorString.includes("429")) {
        errorMessage = "Looks like I got a bit too excited! The image generator is on a short break. Please wait a moment and try again.";
      }
      setGenerationError(errorMessage);
    } finally {
      setIsGeneratingImage(false);
    }
  };

  const handlePickWord = () => {
    let currentDeck = [...wordDeck];

    // If the deck is empty, reshuffle and start a new one.
    if (currentDeck.length === 0) {
      currentDeck = getShuffledDictionary();
    }

    const entry = currentDeck.shift();
    if (entry) {
      setPickedWord(entry);
      setWordDeck(currentDeck);
    }
  };


  const closeImageModal = () => {
    setIsImageModalOpen(false);
  };

  return (
    <div className="flex flex-col min-h-screen w-full font-sans text-stone-300 bg-stone-900 items-center p-4 pt-16 sm:pt-24">
        <header className="text-center mb-10">
            <h1 className="text-4xl md:text-5xl font-bold tracking-wider text-amber-400 mb-2">
                Kriol Dikshineri
            </h1>
            <p className="text-stone-400 max-w-xl">Discover the Belize Kriol language. Pick a random word, then generate a beautiful AI-powered image for it.</p>
        </header>
        
        <main className="flex flex-col items-center w-full">
            <div className="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
                <button
                    onClick={handlePickWord}
                    className="flex items-center justify-center gap-3 w-64 px-6 py-4 bg-stone-700 text-stone-200 font-semibold rounded-lg shadow-lg hover:bg-stone-600 focus:outline-none focus:ring-4 focus:ring-stone-500 focus:ring-opacity-50 transform hover:scale-105 transition-all duration-300 disabled:bg-stone-800 disabled:cursor-not-allowed"
                    disabled={isImageModalOpen}
                    aria-label="Pick a random word"
                >
                    <DiceIcon />
                    <span>Pick a Random Word</span>
                </button>
                <button
                    onClick={handleGenerateImage}
                    className="flex items-center justify-center gap-3 w-64 px-6 py-4 bg-amber-600 text-white font-semibold rounded-lg shadow-lg hover:bg-amber-500 focus:outline-none focus:ring-4 focus:ring-amber-400 focus:ring-opacity-50 transform hover:scale-105 transition-all duration-300 disabled:bg-amber-800 disabled:text-amber-500 disabled:cursor-not-allowed disabled:scale-100"
                    disabled={isImageModalOpen || !pickedWord}
                    aria-label={pickedWord ? `Generate visual for ${pickedWord.kriol}` : "Pick a word first to generate a visual"}
                >
                    <ImageIcon />
                    <span>Generate Visual Word</span>
                </button>
            </div>
            
            {pickedWord && (
                <div className="w-full max-w-md animate-fade-in">
                    <WordCard entry={pickedWord} />
                </div>
            )}
        </main>

        <footer className="w-full text-center text-stone-500 text-sm mt-auto py-4">
            <p>Powered by AI. Explore the beauty of Belize Kriol.</p>
        </footer>

        <ImageModal
            isOpen={isImageModalOpen}
            isLoading={isGeneratingImage}
            content={generatedContent}
            error={generationError}
            onClose={closeImageModal}
        />
    </div>
  );
};

export default App;
